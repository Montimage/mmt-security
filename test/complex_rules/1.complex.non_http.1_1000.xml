<!--This file is repeated from complex_rules/non-http.xml -->

<!-- ================LOOP 0 ==================-->

<beginning>

<embedded_functions><![CDATA[
//each function name should be prefixed by em_

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include "types_defs.h"

static inline int check_ip_options(const char *op2, const char *op1){
  int handle = 0;
  
  int i2 = *((int*)op2);
  int i1 = *((int*)op1);
  int bit2 = (i2 >> 1) & 1;
  int bit1 = (i1 >> 1) & 1;
//  if(bit2 == 1 || bit1 == 1){
      if(i2 != i1) handle = 1;
//  }
  return handle;
}


static inline int check_port(int i){
  
  //printf("Port:%d\n", i);
  //according to: 
  //https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers
  //and
  //https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt

  if(i<1023) return 0;
  if(i>49151 && i< 65536) return 0;
  if(i>65535) return 1;

  if(i>2193 && i<2197) return 1;
  if(i>4488 && i<4500) return 1;
  if(i>4953 && i<4969) return 1;
  if(i>5569 && i<5573) return 1;
  if(i>5646 && i<5670) return 1;
  if(i>6657 && i<6665) return 1;
  if(i>7491 && i<7500) return 1;
  if(i>7784 && i<7790) return 1;
  if(i>27999 && i<28119) return 1;
  if(i>5554 && i<5558) return 1;
  if(i>5999 && i<6064) return 1;
  if(i>8615 && i<8665) return 1;
  if(i>8801 && i<8804) return 1;
  if(i>8887 && i<8891) return 1;
  if(i>11430 && i<11489) return 1;
  if(i>11623 && i<11720) return 1;
  if(i>27009 && i<27345) return 1;
  if(i>41797 && i<42508) return 1;
  if(i>44444 && i<44544) return 1;
  switch (i) {
    case 78:
    case 79:
    case 100:
    case 106:
    case 787:
    case 1053:
    case 1491:
    case 2662:
    case 3060:
    case 3131:
    case 3145:
    case 3300:
    case 3301:
    case 4045:
    case 4315:
    case 4443:
    case 4967:
    case 5151:
    case 5152:
    case 5162:
    case 5444:
    case 5555:
    case 5556:
    case 6100:
    case 6200:
    case 6501:
    case 8882:
    case 9001:
    case 6632:
    case 7001:
    case 7002:
    case 7005:
    case 7011:
    case 7012:
    case 7501:
    case 7777:
    case 8001:
    case 16000:
    case 49151:
      return 1;
    default:
      return 0;
  }
  return 0;
}

/**
* Return:
* - 0: ok
* - 1: invalid
* - 2: NULL
*/
static inline int check_URI(const char *uri_str){
  int handle = 0;
  if(uri_str == NULL){
    return 2;
  }
 
  const char *x = uri_str;
  
  //fprintf(stderr, "%s\n",x);
  while (*x != '\0'){
      //octets 0-32 (0-20 hex) | "\" | """ | "&" | "<" | ">" | "[" | "]" | "^" | "`" | "{" | "|" | "}" | "~" | octets 127-255 (7F-FF hex)
      if(*x < 32 || *x == 92 || *x == '"' || *x == '<' || *x == '>' || *x == '[' || *x == ']' || *x == '^' || *x == '`' || *x == '{' || 
         *x == '|' || *x == '}' || *x == '%' || *x > 126) {
              handle = 1;
              break;
      }
      x = x+1;
  }
  //detect directory traversal attack
  char *s0, *s1, *s2, *s3;
  s0 = strstr(uri_str, ".."); //find the first occurrence of string ".." in string
  s1 = strstr(uri_str, "./"); //find the first occurrence of string "./" in string
  s2 = strstr(uri_str, "//"); //find the first occurrence of string "//" in string
  s3 = strstr(uri_str, "/."); //find the first occurrence of string "//" in string
  
  if ((s0 !=NULL) || (s1 !=NULL) || (s2 !=NULL) || (s3 !=NULL))  
   handle = 1;
   
//#ifdef DEBUG
//  fprintf(stderr, "executing ceck_URI with parameters:h=%d:nb=%u:a1=%o:a2=%o\n", 
//                                           handle, *(char*)(BLOC3+6),*(char*)(BLOC3+9));
//#endif
  return handle;
}

/*
 * Nikto 
 */
static inline bool check_UA( const char *user_agent){
   //find the first occurrence of string "Nikto" in string
   return (strstr(user_agent, "Nikto") != NULL);     
}

static inline int check_sql_injection(const void *p_payload, double payload_len){
   int key_word_len = 6;
   char *key_words[6] = {"DROP", "UNION", "SELECT", "CHAR", "DELETE", "INSERT"};
   size_t len = payload_len, i;
   char *str  = malloc( len + 1 );
   memcpy( str, p_payload, len );
   str[ len ] = '\0';
   
   //Signature based dection begin here. 
   //(using  pattern matching techniques against signatures and 
   //keyword-based stores to identify potentially malicious requests)
   for( i=0; i<key_word_len; i++)
      if( strstr(str, key_words[i]  ) != NULL ){
         free( str );
         return 1;
      }
   
   free( str );
   return 0;
}



int check_http_response(const char* p){
  if(p == NULL){
    return 1;
  }
  return 0;
}

int check_ip_add(const char *src, const char *dst, const char *src1, const char *dst1){
  if((src == NULL) || (dst == NULL) || (src1 == NULL) || (dst1 == NULL)){
    return 1;
  }
  if (((src = src1) && (dst = dst1)) || ((src = dst1) && (dst = src1))){
     return 1;
  }
  return 0;
}

]]></embedded_functions>

<!-- Property 1: Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).-->
<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "1" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "2" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "3" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "4" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "5" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "6" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "7" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "8" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "9" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "10" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "11" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "12" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "13" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "14" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "15" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "16" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "17" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 1 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "18" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "19" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "20" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "21" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "22" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "23" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "24" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "25" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "26" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "27" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "28" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "29" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "30" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "31" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "32" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "33" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "34" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 2 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "35" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "36" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "37" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "38" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "39" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "40" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "41" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "42" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "43" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "44" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "45" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "46" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "47" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "48" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "49" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "50" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "51" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 3 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "52" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "53" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "54" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "55" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "56" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "57" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "58" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "59" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "60" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "61" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "62" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "63" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "64" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "65" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "66" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "67" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "68" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 4 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "69" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "70" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "71" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "72" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "73" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "74" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "75" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "76" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "77" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "78" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "79" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "80" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "81" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "82" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "83" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "84" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "85" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 5 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "86" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "87" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "88" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "89" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "90" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "91" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "92" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "93" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "94" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "95" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "96" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "97" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "98" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "99" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "100" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "101" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "102" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 6 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "103" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "104" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "105" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "106" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "107" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "108" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "109" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "110" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "111" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "112" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "113" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "114" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "115" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "116" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "117" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "118" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "119" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 7 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "120" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "121" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "122" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "123" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "124" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "125" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "126" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "127" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "128" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "129" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "130" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "131" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "132" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "133" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "134" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "135" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "136" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 8 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "137" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "138" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "139" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "140" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "141" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "142" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "143" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "144" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "145" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "146" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "147" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "148" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "149" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "150" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "151" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "152" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "153" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 9 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "154" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "155" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "156" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "157" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "158" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "159" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "160" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "161" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "162" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "163" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "164" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "165" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "166" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "167" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "168" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "169" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "170" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 10 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "171" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "172" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "173" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "174" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "175" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "176" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "177" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "178" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "179" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "180" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "181" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "182" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "183" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "184" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "185" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "186" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "187" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 11 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "188" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "189" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "190" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "191" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "192" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "193" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "194" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "195" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "196" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "197" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "198" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "199" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "200" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "201" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "202" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "203" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "204" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 12 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "205" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "206" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "207" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "208" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "209" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "210" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "211" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "212" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "213" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "214" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "215" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "216" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "217" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "218" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "219" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "220" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "221" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 13 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "222" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "223" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "224" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "225" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "226" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "227" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "228" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "229" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "230" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "231" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "232" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "233" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "234" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "235" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "236" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "237" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "238" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 14 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "239" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "240" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "241" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "242" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "243" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "244" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "245" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "246" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "247" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "248" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "249" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "250" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "251" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "252" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "253" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "254" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "255" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 15 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "256" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "257" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "258" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "259" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "260" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "261" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "262" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "263" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "264" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "265" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "266" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "267" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "268" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "269" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "270" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "271" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "272" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 16 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "273" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "274" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "275" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "276" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "277" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "278" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "279" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "280" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "281" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "282" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "283" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "284" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "285" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "286" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "287" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "288" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "289" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 17 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "290" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "291" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "292" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "293" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "294" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "295" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "296" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "297" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "298" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "299" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "300" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "301" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "302" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "303" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "304" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "305" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "306" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 18 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "307" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "308" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "309" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "310" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "311" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "312" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "313" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "314" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "315" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "316" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "317" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "318" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "319" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "320" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "321" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "322" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "323" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 19 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "324" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "325" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "326" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "327" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "328" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "329" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "330" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "331" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "332" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "333" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "334" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "335" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "336" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "337" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "338" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "339" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "340" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 20 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "341" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "342" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "343" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "344" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "345" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "346" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "347" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "348" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "349" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "350" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "351" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "352" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "353" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "354" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "355" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "356" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "357" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 21 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "358" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "359" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "360" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "361" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "362" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "363" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "364" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "365" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "366" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "367" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "368" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "369" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "370" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "371" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "372" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "373" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "374" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 22 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "375" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "376" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "377" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "378" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "379" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "380" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "381" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "382" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "383" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "384" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "385" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "386" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "387" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "388" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "389" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "390" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "391" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 23 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "392" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "393" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "394" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "395" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "396" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "397" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "398" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "399" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "400" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "401" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "402" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "403" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "404" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "405" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "406" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "407" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "408" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 24 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "409" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "410" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "411" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "412" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "413" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "414" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "415" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "416" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "417" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "418" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "419" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "420" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "421" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "422" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "423" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "424" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "425" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 25 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "426" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "427" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "428" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "429" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "430" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "431" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "432" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "433" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "434" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "435" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "436" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "437" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "438" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "439" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "440" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "441" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "442" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 26 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "443" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "444" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "445" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "446" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "447" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "448" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "449" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "450" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "451" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "452" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "453" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "454" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "455" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "456" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "457" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "458" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "459" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 27 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "460" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "461" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "462" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "463" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "464" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "465" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "466" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "467" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "468" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "469" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "470" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "471" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "472" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "473" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "474" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "475" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "476" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 28 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "477" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "478" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "479" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "480" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "481" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "482" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "483" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "484" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "485" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "486" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "487" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "488" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "489" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "490" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "491" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "492" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "493" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 29 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "494" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "495" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "496" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "497" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "498" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "499" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "500" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "501" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "502" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "503" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "504" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "505" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "506" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "507" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "508" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "509" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "510" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 30 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "511" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "512" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "513" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "514" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "515" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "516" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "517" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "518" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "519" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "520" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "521" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "522" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "523" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "524" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "525" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "526" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "527" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 31 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "528" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "529" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "530" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "531" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "532" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "533" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "534" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "535" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "536" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "537" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "538" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "539" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "540" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "541" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "542" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "543" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "544" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 32 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "545" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "546" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "547" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "548" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "549" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "550" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "551" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "552" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "553" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "554" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "555" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "556" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "557" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "558" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "559" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "560" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "561" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 33 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "562" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "563" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "564" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "565" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "566" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "567" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "568" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "569" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "570" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "571" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "572" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "573" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "574" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "575" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "576" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "577" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "578" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 34 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "579" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "580" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "581" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "582" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "583" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "584" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "585" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "586" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "587" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "588" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "589" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "590" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "591" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "592" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "593" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "594" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "595" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 35 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "596" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "597" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "598" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "599" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "600" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "601" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "602" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "603" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "604" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "605" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "606" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "607" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "608" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "609" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "610" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "611" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "612" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 36 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "613" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "614" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "615" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "616" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "617" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "618" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "619" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "620" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "621" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "622" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "623" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "624" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "625" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "626" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "627" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "628" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "629" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 37 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "630" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "631" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "632" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "633" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "634" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "635" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "636" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "637" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "638" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "639" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "640" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "641" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "642" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "643" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "644" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "645" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "646" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 38 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "647" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "648" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "649" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "650" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "651" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "652" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "653" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "654" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "655" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "656" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "657" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "658" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "659" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "660" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "661" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "662" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "663" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 39 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "664" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "665" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "666" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "667" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "668" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "669" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "670" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "671" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "672" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "673" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "674" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "675" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "676" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "677" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "678" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "679" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "680" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 40 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "681" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "682" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "683" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "684" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "685" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "686" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "687" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "688" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "689" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "690" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "691" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "692" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "693" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "694" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "695" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "696" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "697" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 41 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "698" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "699" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "700" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "701" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "702" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "703" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "704" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "705" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "706" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "707" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "708" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "709" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "710" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "711" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "712" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "713" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "714" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 42 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "715" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "716" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "717" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "718" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "719" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "720" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "721" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "722" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "723" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "724" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "725" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "726" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "727" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "728" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "729" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "730" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "731" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 43 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "732" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "733" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "734" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "735" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "736" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "737" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "738" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "739" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "740" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "741" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "742" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "743" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "744" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "745" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "746" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "747" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "748" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 44 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "749" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "750" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "751" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "752" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "753" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "754" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "755" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "756" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "757" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "758" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "759" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "760" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "761" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "762" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "763" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "764" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "765" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 45 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "766" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "767" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "768" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "769" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "770" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "771" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "772" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "773" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "774" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "775" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "776" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "777" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "778" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "779" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "780" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "781" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "782" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 46 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "783" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "784" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "785" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "786" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "787" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "788" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "789" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "790" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "791" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "792" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "793" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "794" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "795" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "796" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "797" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "798" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "799" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 47 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "800" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "801" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "802" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "803" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "804" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "805" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "806" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "807" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "808" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "809" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "810" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "811" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "812" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "813" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "814" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "815" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "816" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 48 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "817" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "818" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "819" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "820" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "821" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "822" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "823" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "824" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "825" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "826" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "827" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "828" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "829" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "830" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "831" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "832" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "833" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 49 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "834" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "835" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "836" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "837" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "838" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "839" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "840" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "841" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "842" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "843" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "844" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "845" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "846" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "847" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "848" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "849" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "850" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 50 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "851" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "852" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "853" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "854" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "855" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "856" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "857" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "858" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "859" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "860" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "861" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "862" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "863" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "864" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "865" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "866" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "867" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 51 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "868" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "869" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "870" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "871" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "872" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "873" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "874" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "875" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "876" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "877" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "878" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "879" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "880" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "881" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "882" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "883" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "884" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 52 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "885" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "886" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "887" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "888" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "889" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "890" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "891" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "892" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "893" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "894" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "895" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "896" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "897" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "898" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "899" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "900" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "901" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 53 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "902" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "903" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "904" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "905" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "906" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "907" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "908" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "909" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "910" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "911" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "912" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "913" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "914" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "915" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "916" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "917" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "918" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 54 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "919" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "920" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "921" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "922" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "923" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "924" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "925" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "926" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "927" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "928" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "929" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "930" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "931" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "932" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "933" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "934" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "935" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 55 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "936" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "937" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "938" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "939" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "940" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "941" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "942" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "943" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "944" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "945" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "946" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "947" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "948" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "949" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "950" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "951" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "952" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 56 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "953" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "954" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "955" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "956" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "957" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "958" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "959" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "960" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "961" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "962" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "963" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "964" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "965" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "966" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "967" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "968" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "969" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 57 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "970" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "971" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "972" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "973" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "974" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "975" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "976" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "977" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "978" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "979" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "980" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "981" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "982" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "983" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "984" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "985" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "986" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


<!-- ================LOOP 58 ==================-->

<property value="THEN" delay_units="m" delay_min="0+" delay_max="1" property_id = "987" 
    description="Several attempts to connect via ssh (brute force attack). Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="3" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;(ip.dst == ip.dst.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;(ip.src == ip.dst.1))))"/>
    </operator>
</property>

<!-- Property 2: Attempted to connect via ssh but reseted immediately. Source address is spoofed, infected machine or attacker.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="500" property_id = "988" 
    description="Attempted to connect via ssh but reseted immediately. Source address is either infected machine or attacker (no spoofing is possible).">
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="1">
      <event value="COMPUTE" event_id="1" 
             description="SYN request"
             boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="SYN ACK reply"
             boolean_expression="((tcp.flags == 18)&amp;&amp;((tcp.src_port == 22)&amp;&amp;((ip.dst == ip.src.2)&amp;&amp;(ip.src == ip.dst.2))))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="RST reset"
           boolean_expression="((tcp.flags == 4)&amp;&amp;((tcp.dest_port == 22)&amp;&amp;((ip.dst == ip.dst.2)&amp;&amp;(ip.src == ip.src.2))))"/>
</property>

<!-- Property 3: Several TCP SYN requests without SYN ACK. Source address is spoofed, infected machine or attacker. Note: done on port 445.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="6" property_id = "989" 
    description="TCP SYN requests on microsoft-ds port 445 with SYN ACK."
    >
    <!--if_not_satisfied="py_createstix(3_BGPOST_TCP_SYN_request_without_SYN_ACK_could_be_a_spoofed_address, ip.src.8)"-->
    <event value="COMPUTE" event_id="1"
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((tcp.dest_port == 445)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN ACK reply"
           boolean_expression="((tcp.flags == 18)&amp;&amp;(ip.src == ip.dst.1))"/>
</property>

<!-- These properties analyse ARP messages using the following packet fields:
        ar_op  : ARP OPCODE field that identifies if it is a REQUEST (value 1) or a REPLY (value 2)
        ar_sip : Sender IP address (IP address of the device sending the ARP message)
        ar_tip : Target IP address (IP address of the target device)
        ar_sha : Sender MAC address (MAC address of the sender device)

     Note that these properties detect possible attacks. There are cases where they are not, such as when one needs to:
        change a device and reuse the same IP address,
        change the MAC address of a device.
-->

<!-- Property 4: One ARP request receives two replies with different MAC addresses.-->
 
<property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "990" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
    <operator value="THEN" delay_units="m" delay_min="0+" delay_max="5">
      <event value="COMPUTE" event_id="1" 
             description="An arp who was requested"
             boolean_expression="((arp.ar_op == 1)&amp;&amp;(ethernet.src != ethernet.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;(ethernet.src != ethernet.dst)))"/>
    </operator>
    <event value="COMPUTE" event_id="3" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_tip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.2)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>

<!-- Property 5: Two ARP replies that should provide the same MAC address are different. This rule is simpler than Property 1 
                 above and detects the same potential attacks without generating a message for each combination of request-reply.-->

 <property value="THEN" delay_units="m" delay_min="0+" delay_max="5" property_id = "991" 
          description="IPv4 address conflict detection (RFC5227). Possible arp poisoning.">
      <event value="COMPUTE" event_id="1" 
             description="An arp reply with MAC address"
             boolean_expression="((arp.ar_op == 2)&amp;&amp;(ethernet.src != ethernet.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="An arp reply but with different MAC address"
           boolean_expression="((arp.ar_op == 2)&amp;&amp;((arp.ar_sip == arp.ar_sip.1)&amp;&amp;((arp.ar_sha != arp.ar_sha.1)&amp;&amp;(ethernet.src != ethernet.dst))))"/>
</property>


<!-- Property 6: 4_Analyse_03b : TCP SYN scan to detect SYNFUL compromise) (|ack - seq| == 0xC123D ou 791101). -->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "992" 
    description="4_Analyse_03b : SYN and ACK paquets with a 0xC123D delta between TCP sequence numbers (scan done by SYNFUL attack).">
    <event value="COMPUTE" event_id="1"
           description="TCP SYN"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst == ip.dst)&amp;&amp;((ip.src == ip.src)&amp;&amp;(tcp.seq_nb == tcp.seq_nb))))"/>
    <event value="COMPUTE" event_id="2" 
           description="TCP ACK"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((ip.dst == ip.src.1)&amp;&amp;((ip.src == ip.dst.1)&amp;&amp;(((tcp.ack_nb - tcp.seq_nb.1) == 791101)||((tcp.seq_nb.1 - tcp.ack_nb) == 791101)))))"/>
</property>

<!-- Property 7: R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb .-->
<property value="BEFORE" delay_units="ms" delay_min="0+" delay_max="1" property_id = "993" 
    description="R4_Decod_1a : TCP RST is invalid if there is no corresponding TCP ACK (tcp.flags == 16) before belonging to the same session containing correct seq_nb and ack_nb.">
    <event value="COMPUTE" event_id="1"
           description="Context: TCP RST"
           boolean_expression="((tcp.rst == 1)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;((tcp.ack_nb.2 != tcp.seq_nb)&amp;&amp;((ip.src.2 == ip.dst)&amp;&amp;(ip.dst.2 == ip.src)))))"/>
    <event value="COMPUTE" event_id="2" 
           description="Trigger: the last TCP ACK packets have different seg_nb and ack_nb"
           boolean_expression="((tcp.flags == 16)&amp;&amp;((tcp.ack_nb == tcp.ack_nb)&amp;&amp;((tcp.seq_nb == tcp.seq_nb)&amp;&amp;(ip.src != ip.dst))))"/>
</property>


<!-- TODO:
R4_Decod_1c et R4_Decod_1d : Using fragroute

C4_Analyse_1a : Il faut quelques regles qui analysent les champs de certains protocoles

C4_Analyse_03a : la fonction de defragmentation detecte un chevauchement des zones de donnees transportees par des fragments IP (attack teardrop)

Autres tentatives sur IP et/ou TCP : depend de la genericite des regles par rapport aux sequences protocolaires generees par les outils (fragroute, etc.)
-->

<!-- Property 8: C4_Analyse_03g : Le champ Options doit etre homogene dans tous les fragments IP.-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "994" 
    description="C4_Analyse_03g: The IP options field must be homogeneous in all IP fragments.">
    <event value="COMPUTE" event_id="1" 
           description="IP segment"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.options == ip.options)&amp;&amp;(ip.src != ip.dst)))"/>
    <event value="COMPUTE" event_id="2" 
           description="IP options"
           boolean_expression="((ip.mf_flag &gt; 0)&amp;&amp;((ip.src == ip.src.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(#check_ip_options(ip.options,ip.options.1) == 1))))"/>
</property>

 <!-- Property 16: C4_Analyse_02 : Two successive TCP SYN requests but with different destination addresses.-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="10" property_id = "995" 
    description="Two successive TCP SYN requests but with different destination addresses."
    >
    <!--if_satisfied="py_createstix(5_two_successive_TCP_SYN_requests_could_be_a_spoofed_address, ip.src.12)"-->
    <event value="COMPUTE" event_id="1" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;(ip.src != ip.dst))"/>
    <event value="COMPUTE" event_id="2" 
           description="SYN request"
           boolean_expression="((tcp.flags == 2)&amp;&amp;((ip.dst != ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
</property>



<!-- Property 20: C4_Analyse_04i: ICMP redirect flood detection-->
<!-- Depending on OS implementation, these host based routes can have the characteristic of being short lived.  
Solaris implements aggressive aging where redirects will only last for a specified amount of time.  
Each redirect is given a short lifetime value and will be automatically removed from the routing table when the timer expires.   
This is to ensure that redirects do not remain the routing table indefinitely at the risk of further sub optimal routing.  
In BSD networking code, redirects will be removed if they are being used by TCP and only after the fourth consecutive retransmission attempt.  
Routed and Gated perform similar forms of redirect expiration.  
Since ICMP redirects are dynamic and may not reflect the most current topology 
it is nice to have an automated method of redirect expiration.
-->

<property value="THEN" delay_units="ms" delay_min="0" delay_max="6" property_id = "996" 
    description="4 consecutive ICMP redirect packets. Possibly ICMP redirect flood."
    >
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="1" 
           description="Context: ICMP redirect"
           boolean_expression="((icmp.type == 5)&amp;&amp;(ip.dst != ip.src))"/>
   <event value="COMPUTE" event_id="2" 
           description="Trigger: 2nd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
   <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="3">
   <event value="COMPUTE" event_id="3" 
           description="Trigger: 3rd consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   <event value="COMPUTE" event_id="4" 
           description="Trigger: 4th consecutive ICMP redirect packet"
           boolean_expression="((icmp.type == 5)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
   </operator>
</property>

<!-- Property 21: IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "997" 
    description="IP fragmentation : fragments with offset always = 0 (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment with offset = 0 followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset = 0"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset == 0)&amp;&amp;(ip.src != ip.dst)))"/>
</property>
<!--
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;((((ip.frag_offset - ip.frag_offset.1) &lt; 101)&amp;&amp;ip.src != ip.dst))))"/>
-->

<!-- Property 22: IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "998" 
    description="IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 23: Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "999" 
    description="Out of order IP fragmentation : a fragment with a size less than 9 bytes (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and an offset less than 9 bytes"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; 9)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 24: Overlapping IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "1000" 
    description="Overlapping IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &gt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset - ip.frag_offset.1) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 25: Overlapping unordered IP fragmentation : difference in offset of concomitant fragments < fragment length (allowed but could be an evasion).-->
<property value="THEN" delay_units="ms" delay_min="0+" delay_max="1" property_id = "1001" 
    description="Overlapping unordered IP fragmentation : difference in offset of concomitant fragments less than fragment length (allowed but could be an evasion).">
      <event value="COMPUTE" event_id="1" 
             description="IP fragment followed by another"
             boolean_expression="((ip.identification &gt; 0)&amp;&amp;((ip.mf_flag == 1)&amp;&amp;((ip.frag_offset &gt;= 0)&amp;&amp;(ip.src != ip.dst))))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP fragment with same identification and diffenrences in offsets less than length"
             boolean_expression="((ip.identification == ip.identification.1)&amp;&amp;((ip.frag_offset &lt; ip.frag_offset.1)&amp;&amp;(((ip.frag_offset.1 - ip.frag_offset) &lt; ip.tot_len)&amp;&amp;(ip.src != ip.dst))))"/>
</property>

<!-- Property 26: Probable IP protocol scan (4 different attempts in a row on different protocols).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "1002" 
    description="Probable IP protocol scan (4 different attempts in a row on different protocols)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
          description="IP packet header with the eight-bit IP protocol field set (1)"
             boolean_expression="((ip.proto_id != 0)&amp;&amp;(ip.src != ip.dst))"/>
      <event value="COMPUTE" event_id="2" 
             description="IP packet header with another eight-bit IP protocol field set (2)"
             boolean_expression="((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="IP packet header with another eight-bit IP protocol field set (3)"
             boolean_expression="((ip.proto_id != ip.proto_id.2)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
      <event value="COMPUTE" event_id="4" 
             description="IP packet header with another eight-bit IP protocol field set (4)"
             boolean_expression="((ip.proto_id != ip.proto_id.3)&amp;&amp;((ip.proto_id != ip.proto_id.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
</property>

<!-- Property 27: Probable UDP protocol scan (4 different attempts in a row on different ports).
-->

<property value="THEN" delay_units="ms" delay_min="0+" delay_max="20" property_id = "1003" 
    description="Probable UDP protocol scan (4 different attempts in a row on different ports)."
    >
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="1" 
             description="UDP packet header with a destination port field set (1)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != 0)&amp;&amp;(ip.src != ip.dst)))"/>
      <event value="COMPUTE" event_id="2" 
             description="UDP packet header with another destination port field set (2)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1))))"/>
    </operator>
    <operator value="THEN" delay_units="ms" delay_min="0+" delay_max="10">
      <event value="COMPUTE" event_id="3" 
             description="UDP packet header with another destination port field set (3)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.2)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
      <event value="COMPUTE" event_id="4"
             description="UDP packet header with another destination port field set (4)"
             boolean_expression="((ip.proto_id == 17)&amp;&amp;((udp.dest_port != udp.dest_port.3)&amp;&amp;((udp.dest_port != udp.dest_port.1)&amp;&amp;((ip.dst == ip.dst.1)&amp;&amp;(ip.src == ip.src.1)))))"/>
    </operator>
</property>


</beginning>

<!-- 2017/03/07 15:16:09 Generated 1000 from 17 distinct rules in 59 loops -->